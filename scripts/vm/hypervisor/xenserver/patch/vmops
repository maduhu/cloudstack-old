#!/usr/bin/python
#
# A plugin for executing script needed by vmops cloud 

import os, sys, time
import XenAPIPlugin
sys.path.append("/opt/xensource/sm/")
import SR, VDI, SRCommand, util, lvutil
import vhdutil
import shutil
import lvhdutil
import subprocess
import SR, VDI
import errno
import xs_errors
from lvmcache import LVMCache
from journaler import Journaler
from lock import Lock
import os, time
import errno
import shutil
import subprocess
import xs_errors
import cleanup

VHD_UTIL = '/usr/sbin/vhd-util'
def echo(fn):
    def wrapped(*v, **k):
        name = fn.__name__
        util.SMlog("#### VMOPS enter  %s ####" % name )
        res = fn(*v, **k)
        util.SMlog("#### VMOPS exit  %s ####" % name )
        return res
    return wrapped

@echo
def getvncport(session, args):
    domid = args['domID']
    hvm = args['hvm']
    if hvm == 'true':
        path = "/local/domain/" + domid + "/console/vnc-port"
    else:
        path = "/local/domain/" + domid + "/serial/0/vnc-port"
    try:
        cmd = ["xenstore-read", path]
        txt = util.pread2(cmd)
    except:
        txt = ''
 
    return txt
    
    
@echo
def getnetwork(session, args):
    mgmt_ip = args['mgmtIP']
    try:
        cmd = ["bash", "/opt/xensource/bin/network_info.sh", "-l", mgmt_ip]
        txt = util.pread2(cmd)
    except:
        txt = ''
    
    return txt

@echo
def getgateway(session, args):
    mgmt_ip = args['mgmtIP']
    try:
        cmd = ["bash", "/opt/xensource/bin/network_info.sh", "-g", mgmt_ip]
        txt = util.pread2(cmd)
    except:
        txt = ''

    return txt

@echo
def preparemigration(session, args):
    uuid = args['uuid']
    try:
        cmd = ["/opt/xensource/bin/make_migratable.sh", uuid]
        util.pread2(cmd)
        txt = 'success'
    except:
        util.SMlog("Catch prepare migration exception" )
        txt = ''

    return txt

@echo
def setIptables(session, args):
    try:
        f = open("/proc/sys/fs/aio-max-nr", 'w')
        f.write("1048576")
        f.close()
        try:
            cmd = ["iptables", "-D", "RH-Firewall-1-INPUT", "-p", "tcp", "-m", "tcp", "--dport", "5900:6099", "-j", "ACCEPT"]
            txt = util.pread2(cmd)
        except:
	    txt = ''

        cmd = ["iptables", "-I", "RH-Firewall-1-INPUT", "-p", "tcp", "-m", "tcp", "--dport", "5900:6099", "-j", "ACCEPT"]
        txt = util.pread2(cmd)
        txt = 'success'
    except:
        util.SMlog("  setIptables execution failed "  )
        txt = ''
    util.SMlog("execute setIptables command result (%s), ignoring" % txt)

    return txt
 
@echo
def patchdomr(session, args):
    vmname = args['vmname']
    vmtype = args['vmtype']
    device = args['device']
    try:
        cmd = ["/bin/bash", "/opt/xensource/bin/rundomrpre.sh", "-l", vmname, "-t", vmtype, "-d", device]
        txt = util.pread2(cmd)
        txt = 'success'
    except:
        util.SMlog("  patch domr failed "  )
        txt = '' 

    return txt


@echo
def ipassoc(session, args):
    sargs = args['args']
    cmd = sargs.split(' ')
    cmd.insert(0, "/opt/xensource/bin/ipassoc.sh")
    cmd.insert(0, "/bin/bash")
    try:
        txt = util.pread2(cmd)
        txt = 'success'
    except:
        util.SMlog("  ip associate failed "  )
        txt = '' 

    return txt

@echo
def savePassword(session, args):
    sargs = args['args']
    cmd = sargs.split(' ')
    cmd.insert(0, "/opt/xensource/bin/save_password_to_domr.sh")
    cmd.insert(0, "/bin/bash")
    try:
        txt = util.pread2(cmd)
        txt = 'success'
    except:
        util.SMlog("  save password to domr failed "  )
        txt = '' 

    return txt

@echo
def saveDhcpEntry(session, args):
    sargs = args['args']
    cmd = sargs.split(' ')
    cmd.insert(0, "/opt/xensource/bin/dhcp_entry.sh")
    cmd.insert(0, "/bin/bash")
    try:
        txt = util.pread2(cmd)
        txt = 'success'
    except:
        util.SMlog(" save dhcp entry failed "  )
        txt = '' 

    return txt

@echo
def setFirewallRule(session, args):
    sargs = args['args']
    cmd = sargs.split(' ')
    cmd.insert(0, "/opt/xensource/bin/firewall.sh")
    cmd.insert(0, "/bin/bash")
    try:
        txt = util.pread2(cmd)
        txt = 'success'
    except:
        util.SMlog(" set firewall rule failed "  )
        txt = '' 

    return txt


@echo
def checkMount(session, args):
    mountPath = args['mount']
    mountPath = os.path.join(SR.MOUNT_BASE, mountPath)
    status = "0"
    try:
        p = subprocess.Popen(["/bin/bash", "-c", "if [ -d " + mountPath + " ]; then echo 1; else echo 0;fi"], stdout=subprocess.PIPE)
        cnt = 10
        while cnt > 0:
            if p.poll() == None:
                time.sleep(1)
                cnt = cnt -1
            else:
                cnt = -1
        if cnt < 0:
            status = p.communicate()[0].strip("\n")	
        else:
            subprocess.Popen(["/bin/bash", "-c", "kill -9 " + str(p.pid)])
            status = "0"

        if status == "0":
            try:
                cmd = ["umount", "-f",  "-l", mountPath]
                txt = util.pread2(cmd)
            except:
                util.SMlog(" umount failed ")
    except:
        util.SMlog("failed to check")
    return status

def isfile(path):
    try:
        if not os.path.isfile(path):
            errMsg = " File " + path + " does not exist."
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)
    except OSError, (errno, strerror):
        errMsg = "OSError with errno: " + str(errno) + " and strerr: " + strerror
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)
    return

def copyfile(fromFile, toFile):
    try:
        shutil.copy2(fromFile, toFile)
    except OSError, (errno, strerror):
        errMsg = "Error while copying " + fromFile + " to " + toFile + " with errno: " + str(errno) + " and strerr: " + strerror
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)
    util.SMlog("Successfully copied " + fromFile + " to " + toFile)

def chdir(path):
    try :
        os.chdir(path)
    except OSError, (errno, strerror):
        errMsg = "Unable to chdir to " + path + " because of OSError with errno: " + str(errno) + " and strerr: " + strerror
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)
    return

def coalesce(vhdPath):
    util.SMlog("Starting to coalesce " + vhdPath + " with its parent")
    try :
        cmd = [VHD_UTIL, "coalesce", "-n", vhdPath]
        txt = util.pread2(cmd)
    except:
        errMsg = "Unexpected error while trying to coalesce " + vhdPath + " to its parent"
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)
    util.SMlog("Successfully coalesced " + vhdPath + " with its parent ")
    
    return

def coalesceToChild(backupVHD, childUUID):
    # coalesce childVHD with its parent
    childVHD = childUUID + '.' + SR.DEFAULT_TAP
    # check for existence of childVHD
    isfile(childVHD)
    # No exception thrown, file exists
    coalesce(childVHD)
    
    # rename the existing backupVHD file to childVHD
    # childVHD file automatically gets overwritten
    try:
        os.rename(backupVHD, childVHD)
    except OSError, (errno, strerror):
        errMsg = "OSError while rename " + backupVHD + " to " + childVHD + "with errno: " + str(errno) + " and strerr: " + strerror
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)

    # parent of the newly coalesced file still remains the same.
    # child of childVHD has it's parent name still set to childVHD.
    # So the VHD chain hasn't been broken.
    return

def mountSecondaryStorage(secondaryStorageMountPath, volumeName):
    # The aim is to mount secondaryStorageMountPath/volumeName
    # Assuming that secondaryStorageMountPath  exists remotely

    # Alex's suggestion and currently implemented:
    # Just mount secondaryStorageMountPath evertime
    # Never unmount.
    
    # Mkdir local mount point dir, if it doesn't exist.
    localMountPointPath = os.path.join(SR.MOUNT_BASE, "snapshots")

    if not os.path.isdir(localMountPointPath):
        try:
            os.makedirs(localMountPointPath)
        except OSError, (errno, strerror):
            errMsg = "OSError while creating " + localMountPointPath + " with errno: " + str(errno) + " and strerr: " + strerror
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)

    # if something is not mounted already on localMountPointPath, 
    # mount again
    if not os.path.ismount(localMountPointPath):
        try: 
            cmd = ['mount', secondaryStorageMountPath, localMountPointPath]
            txt = util.pread2(cmd)
        except:
            txt = ''
            errMsg = "Unexpected error while trying to mount " + secondaryStorageMountPath + " to " + localMountPointPath
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)
        util.SMlog("Successfully mounted " + secondaryStorageMountPath + " to " + localMountPointPath)
        
    # secondaryStorageMountPath has been mounted to localMountPointPath
    
    # Create volumeName dir on localMountPointPath, if it doesn't exist
    backupsDir = os.path.join(localMountPointPath, volumeName)
    if not os.path.isdir(backupsDir):
        try:
            os.mkdir(backupsDir)
        except OSError, (errno, strerror):
            errMsg = "OSError while creating " + backupsDir + " with errno: " + str(errno) + " and strerr: " + strerror
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)

    return backupsDir

@echo
def backupSnapshot(session, args):
    util.SMlog("Called backupSnapshot with " + str(args))
    primaryStorageSRUuid      = args['primaryStorageSRUuid']
    snapshotUuid              = args['snapshotUuid']
    volumeName                = args['volumeName']
    secondaryStorageMountPath = args['secondaryStorageMountPath']
    lastBackedUpBaseCopy      = args['lastBackedUpSnapshotUuid']

    primarySRPath = os.path.join(SR.MOUNT_BASE, primaryStorageSRUuid)
    snapshotVHD  = snapshotUuid + '.' + SR.DEFAULT_TAP
    snapshotPath = os.path.join(primarySRPath, snapshotVHD)
    baseCopyUuid = ''
    try :
        baseCopyUuid = vhdutil.getParent(snapshotPath, cleanup.FileVDI.extractUuid)
    except:
        errMsg = "Could not get vhd parent of " + snapshotPath
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)

    baseCopyPath = os.path.join(primarySRPath, baseCopyUuid)
    baseCopyPath = baseCopyPath + '.' + SR.DEFAULT_TAP
    util.SMlog("Base copy path: " + baseCopyPath)

    # Mount secondary storage mount path on XenServer along the path
    # /var/run/sr-mount/snapshots/ and create <volumeName> dir on it.
    backupsDir = mountSecondaryStorage(secondaryStorageMountPath, volumeName)
    util.SMlog("Backups dir " + backupsDir)

    if baseCopyUuid == lastBackedUpBaseCopy:
        # There has been no change since the last snapshot so no need to backup 
        lastBackedUpBaseCopyPath = os.path.join(backupsDir, lastBackedUpBaseCopy)
        lastBackedUpBaseCopyPath = lastBackedUpBaseCopyPath + '.' + SR.DEFAULT_TAP

        try:
            if not os.path.isfile(lastBackedUpBaseCopyPath):
               util.SMlog("Serious error. Last known backed up base copy " + lastBackedUpBaseCopyPath + " is not present. Trying to backup it again")
            else:
                # The backing up is already done. So return without doing anything further.
                # Set the uuid of the current backup to that of last backup
                txt = "1#" + lastBackedUpBaseCopy
                return txt
        except OSError, (errno, strerror):
            errMsg = "OSError while checking existence of " + lastBackedUpBaseCopyPath + " with errno: " + str(errno) + " and strerr: " + strerror
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)

    # If we reach here, there is no backup present and we have to do one.

    # Check existence of snapshot on primary storage 
    isfile(baseCopyPath)
    # copy baseCopyPath to backupsDir
    copyfile(baseCopyPath, backupsDir)
    
    txt = "1#" + baseCopyUuid
    return txt

@echo
def deleteSnapshotBackup(session, args):
    volumeName                = args['volumeName']
    secondaryStorageMountPath = args['secondaryStorageMountPath']
    backupUUID                = args['backupUUID']
    childUUID                 = args['childUUID']

    backupsDir = mountSecondaryStorage(secondaryStorageMountPath, volumeName)
    # chdir to the backupsDir for convenience
    chdir(backupsDir)

    backupVHD = backupUUID + '.' + SR.DEFAULT_TAP
    util.SMlog("checking existence of " + backupVHD)
    isfile(backupVHD)
        
    # Case 1) childUUID exists
    if childUUID is not None:
        coalesceToChild(backupVHD, childUUID)
    else:
        # Just delete the backupVHD
        try:
            os.remove(backupVHD)
        except OSError, (errno, strerror):
            errMsg = "OSError while removing " + backupVHD + " with errno: " + str(errno) + " and strerr: " + strerror
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)

    return "1"

@echo
def createVolumeFromSnapshot(session, args):
    primaryStorageSRUuid      = args['primaryStorageSRUuid']
    volumeName                = args['volumeName']
    secondaryStorageMountPath = args['secondaryStorageMountPath']
    backedUpSnapshotUuid      = args['backedUpSnapshotUuid']

    primarySRPath = os.path.join(SR.MOUNT_BASE, primaryStorageSRUuid)

    backupsDir = mountSecondaryStorage(secondaryStorageMountPath, volumeName)
    util.SMlog("Backups dir " + backupsDir)

    # chdir to the backupsDir for convenience
    chdir(backupsDir)

    # Get the parent VHD chain of the backupSnapshotVHD
    vhdChain = []
    uuid = backedUpSnapshotUuid
    while uuid is not None:
        util.SMlog("Current uuid in parent chain " + uuid)
        vhd = uuid + '.' + SR.DEFAULT_TAP
        vhdChain.append(vhd)
        try:
            uuid = vhdutil.getParent(vhd, cleanup.FileVDI.extractUuid)
        except:
            errMsg = "Unexpected error while trying to get parent of " + vhd 
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)   
    util.SMlog("successfully created the parent chain " + str(vhdChain))
    # Copy all the vhds to a temp directory
    # Create a temp directory
    tempDir = backupsDir + '_temp'
    try:
        os.mkdir(tempDir)
    except OSError, (errno, strerror):
        errMsg = "OSError while creating tempDir with errno: " + str(errno) + " and strerr: " + strerror
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)

    # Copy
    for vhd in vhdChain:
        vhdPath = os.path.join(backupsDir, vhd)
        copyfile(vhdPath, tempDir)
    util.SMlog("Successfully copied all files")

    # coalesce the vhd chains from bottom to top
    # chdir to tempDir for convenience
    chdir(tempDir)
       
    # coalesce
    i = 0
    for vhd in vhdChain:
        if i == (len(vhdChain) - 1):
            # last vhd, has no parent. Don't coalesce
            break
        i = i + 1
        # They are arranged from child to parent.
        util.SMlog("Starting to coalesce " + vhd + " with its parent")
        try:
            cmd = [VHD_UTIL, "coalesce", "-n", vhd]
            txt = util.pread2(cmd)
        except:
            errMsg = "Unexpected error while trying to coalesce " + vhd + " to its parent" 
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)
        util.SMlog("Successfully coalesced " + vhd + " with its parent")

        # Remove the child vhd
        try:
            os.remove(vhd)
        except OSError, (errno, strerror):
            errMsg = "OSError while removing " + vhd + " with errno: " + str(errno) + " and strerr: " + strerror
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)
    
    finalVhd = vhdChain[len(vhdChain) - 1]
    util.SMlog("successfully coalesced all vhds to the parent " + finalVhd)
    finalVhdPath = os.path.join(tempDir, finalVhd)

    # Copy the final vhd to the primary storage with a different uuid
    # generate a uuid
    newUUID = ''
    try:
        newUUID = util.gen_uuid()
    except:
        errMsg = "Unexpected error while trying to generate a uuid"
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)
    util.SMlog("generated a uuid " + newUUID)

    # new vhd on primary storage
    newVhd = newUUID + '.' + SR.DEFAULT_TAP

    # new vhdPath
    newVhdPath = os.path.join(primarySRPath, newVhd)
    copyfile(finalVhdPath, newVhdPath)

    # delete the temporary directory created on secondary storage
    try:
        shutil.rmtree(tempDir)
    except OSError, (errno, strerror):
        errMsg = "Error while deleting the " + tempDir + " on secondary storage with errno: " + str(errno) + " and strerr: " + strerror + ". Please delete it manually"
        util.SMlog(errMsg)
    util.SMlog("Successfully deleted " + tempDir)

    txt = "1#" + newUUID
    return txt


if __name__ == "__main__":
    XenAPIPlugin.dispatch({"getvncport": getvncport, "getnetwork": getnetwork, "getgateway": getgateway, "preparemigration": preparemigration, "setIptables": setIptables, "patchdomr": patchdomr, "ipassoc": ipassoc, "savePassword": savePassword, "saveDhcpEntry": saveDhcpEntry, "setFirewallRule": setFirewallRule, "checkMount": checkMount, "backupSnapshot": backupSnapshot, "deleteSnapshotBackup": deleteSnapshotBackup, "createVolumeFromSnapshot": createVolumeFromSnapshot})

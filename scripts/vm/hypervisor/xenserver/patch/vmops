#!/usr/bin/python
#
# A plugin for executing script needed by vmops cloud 

import os, sys, time
import XenAPIPlugin
sys.path.append("/opt/xensource/sm/")
import SR, VDI, SRCommand, util, lvutil
import vhdutil
import shutil
import lvhdutil
import subprocess
import SR, VDI
import errno
import xs_errors
from lvmcache import LVMCache
from journaler import Journaler
from lock import Lock
import os, time
import errno
import shutil
import subprocess
import xs_errors
import cleanup
import hostvmstats
import socket

VHD_UTIL = '/usr/sbin/vhd-util'
def echo(fn):
    def wrapped(*v, **k):
        name = fn.__name__
        util.SMlog("#### VMOPS enter  %s ####" % name )
        res = fn(*v, **k)
        util.SMlog("#### VMOPS exit  %s ####" % name )
        return res
    return wrapped

@echo
def gethostvmstats(session, args):
	collect_host_stats = args['collectHostStats']
	consolidation_function = args['consolidationFunction']
	interval = args['interval']
	start_time = args['startTime']
	result = hostvmstats.get_stats(collect_host_stats, consolidation_function, interval, start_time)
	util.SMlog("#### vmStats: " + result)
	return result

@echo
def getvncport(session, args):
    domid = args['domID']
    hvm = args['hvm']
    if hvm == 'true':
        path = "/local/domain/" + domid + "/console/vnc-port"
    else:
        path = "/local/domain/" + domid + "/serial/0/vnc-port"
    try:
        cmd = ["xenstore-read", path]
        txt = util.pread2(cmd)
    except:
        txt = ''
 
    return txt
    
    
@echo
def getnetwork(session, args):
    mgmt_ip = args['mgmtIP']
    try:
        cmd = ["bash", "/opt/xensource/bin/network_info.sh", "-l", mgmt_ip]
        txt = util.pread2(cmd)
    except:
        txt = ''
    
    return txt

@echo
def preparemigration(session, args):
    uuid = args['uuid']
    try:
        cmd = ["/opt/xensource/bin/make_migratable.sh", uuid]
        util.pread2(cmd)
        txt = 'success'
    except:
        util.SMlog("Catch prepare migration exception" )
        txt = ''

    return txt

@echo
def setIptables(session, args):
    try:
        f = open("/proc/sys/fs/aio-max-nr", 'w')
        f.write("1048576")
        f.close()
        try:
            cmd = ["iptables", "-D", "RH-Firewall-1-INPUT", "-p", "tcp", "-m", "tcp", "--dport", "5900:6099", "-j", "ACCEPT"]
            txt = util.pread2(cmd)
        except:
	    txt = ''

        cmd = ["iptables", "-I", "RH-Firewall-1-INPUT", "-p", "tcp", "-m", "tcp", "--dport", "5900:6099", "-j", "ACCEPT"]
        txt = util.pread2(cmd)
        txt = 'success'
    except:
        util.SMlog("  setIptables execution failed "  )
        txt = ''
    util.SMlog("execute setIptables command result (%s), ignoring" % txt)

    return txt
 
@echo
def patchdomr(session, args):
    vmname = args['vmname']
    vmtype = args['vmtype']
    device = args['device']
    try:
        cmd = ["/bin/bash", "/opt/xensource/bin/rundomrpre.sh", "-l", vmname, "-t", vmtype, "-d", device]
        txt = util.pread2(cmd)
        txt = 'success'
    except:
        util.SMlog("  patch domr failed "  )
        txt = '' 

    return txt

@echo
def pingdomr(session, args):
    host = args['host']
    port = args['port']
    socket.setdefaulttimeout(3)
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    try:
        s.connect((host,int(port)))
        txt = 'success'
    except:
        txt = ''
    
    s.close()

    return txt

@echo
def ipassoc(session, args):
    sargs = args['args']
    cmd = sargs.split(' ')
    cmd.insert(0, "/opt/xensource/bin/ipassoc.sh")
    cmd.insert(0, "/bin/bash")
    try:
        txt = util.pread2(cmd)
        txt = 'success'
    except:
        util.SMlog("  ip associate failed "  )
        txt = '' 

    return txt

@echo
def savePassword(session, args):
    sargs = args['args']
    cmd = sargs.split(' ')
    cmd.insert(0, "/opt/xensource/bin/save_password_to_domr.sh")
    cmd.insert(0, "/bin/bash")
    try:
        txt = util.pread2(cmd)
        txt = 'success'
    except:
        util.SMlog("  save password to domr failed "  )
        txt = '' 

    return txt

@echo
def saveDhcpEntry(session, args):
    sargs = args['args']
    cmd = sargs.split(' ')
    cmd.insert(0, "/opt/xensource/bin/dhcp_entry.sh")
    cmd.insert(0, "/bin/bash")
    try:
        txt = util.pread2(cmd)
        txt = 'success'
    except:
        util.SMlog(" save dhcp entry failed "  )
        txt = '' 

    return txt

@echo
def setFirewallRule(session, args):
    sargs = args['args']
    cmd = sargs.split(' ')
    cmd.insert(0, "/opt/xensource/bin/firewall.sh")
    cmd.insert(0, "/bin/bash")
    try:
        txt = util.pread2(cmd)
        txt = 'success'
    except:
        util.SMlog(" set firewall rule failed "  )
        txt = '' 

    return txt


@echo
def checkMount(session, args):
    mountPath = args['mount']
    mountPath = os.path.join(SR.MOUNT_BASE, mountPath)
    status = "0"
    try:
        p = subprocess.Popen(["/bin/bash", "-c", "if [ -d " + mountPath + " ]; then echo 1; else echo 0;fi"], stdout=subprocess.PIPE)
        cnt = 10
        while cnt > 0:
            if p.poll() == None:
                time.sleep(1)
                cnt = cnt -1
            else:
                cnt = -1
        if cnt < 0:
            status = p.communicate()[0].strip("\n")	
        else:
            subprocess.Popen(["/bin/bash", "-c", "kill -9 " + str(p.pid)])
            status = "0"

        if status == "0":
            try:
                cmd = ["umount", "-f",  "-l", mountPath]
                txt = util.pread2(cmd)
            except:
                util.SMlog(" umount failed ")
    except:
        util.SMlog("failed to check")
    return status

def isfile(path):
    try:
        if not os.path.isfile(path):
            errMsg = "File " + path + " does not exist."
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)
    except OSError, (errno, strerror):
        errMsg = "OSError with errno: " + str(errno) + " and strerr: " + strerror
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)
    return

def copyfile(fromFile, toFile):
    try:
        shutil.copy2(fromFile, toFile)
    except OSError, (errno, strerror):
        errMsg = "Error while copying " + fromFile + " to " + toFile + " with errno: " + str(errno) + " and strerr: " + strerror
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)
    util.SMlog("Successfully copied " + fromFile + " to " + toFile)

def chdir(path):
    try :
        os.chdir(path)
    except OSError, (errno, strerror):
        errMsg = "Unable to chdir to " + path + " because of OSError with errno: " + str(errno) + " and strerr: " + strerror
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)
    util.SMlog("Chdired to " + path)
    return

def coalesce(vhdPath):
    util.SMlog("Starting to coalesce " + vhdPath + " with its parent")
    try :
        cmd = [VHD_UTIL, "coalesce", "-n", vhdPath]
        txt = util.pread2(cmd)
    except:
        errMsg = "Unexpected error while trying to coalesce " + vhdPath + " to its parent"
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)
    util.SMlog("Successfully coalesced " + vhdPath + " with its parent ")
    
    return

def getParent(path):
    parentUUID = ''
    try :
        parentUUID = vhdutil.getParent(path, cleanup.FileVDI.extractUuid)
    except:
        errMsg = "Could not get vhd parent of " + path
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)
    return parentUUID

def setParent(parent, child):
    try:
        cmd = [VHD_UTIL, "modify", "-p", parent, "-n", child]
        txt = util.pread2(cmd)
    except:
        errMsg = "Unexpected error while trying to set parent of " + child + " to " + parent 
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)
    util.SMlog("Successfully set parent of " + child + " to " + parent)
    return

def rename(originalVHD, newVHD):
    try:
        os.rename(originalVHD, newVHD)
    except OSError, (errno, strerror):
        errMsg = "OSError while renaming " + origiinalVHD + " to " + newVHD + "with errno: " + str(errno) + " and strerr: " + strerror
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)
    return

def coalesceToChild(backupVHD, childUUID):
    # coalesce childVHD with its parent
    childVHD = childUUID + '.' + SR.DEFAULT_TAP
    # check for existence of childVHD
    isfile(childVHD)
    # No exception thrown, file exists
    coalesce(childVHD)
    
    # rename the existing backupVHD file to childVHD
    # childVHD file automatically gets overwritten
    rename(backupVHD, childVHD)

    # parent of the newly coalesced file still remains the same.
    # child of childVHD has it's parent name still set to childVHD.
    # So the VHD chain hasn't been broken.
    return

def mountSecondaryStorage(secondaryStorageMountPath, volumeName):
    # The aim is to mount secondaryStorageMountPath/volumeName
    # Assuming that secondaryStorageMountPath  exists remotely

    # Alex's suggestion and currently implemented:
    # Just mount secondaryStorageMountPath evertime
    # Never unmount.
    
    # Mkdir local mount point dir, if it doesn't exist.
    localMountPointPath = os.path.join(SR.MOUNT_BASE, "snapshots")

    if not os.path.isdir(localMountPointPath):
        try:
            os.makedirs(localMountPointPath)
        except OSError, (errno, strerror):
            errMsg = "OSError while creating " + localMountPointPath + " with errno: " + str(errno) + " and strerr: " + strerror
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)

    # if something is not mounted already on localMountPointPath, 
    # mount again
    if not os.path.ismount(localMountPointPath):
        try: 
            cmd = ['mount', secondaryStorageMountPath, localMountPointPath]
            txt = util.pread2(cmd)
        except:
            txt = ''
            errMsg = "Unexpected error while trying to mount " + secondaryStorageMountPath + " to " + localMountPointPath
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)
        util.SMlog("Successfully mounted " + secondaryStorageMountPath + " to " + localMountPointPath)
        
    # secondaryStorageMountPath has been mounted to localMountPointPath
    
    # Create volumeName dir on localMountPointPath, if it doesn't exist
    backupsDir = os.path.join(localMountPointPath, volumeName)
    if not os.path.isdir(backupsDir):
        try:
            os.mkdir(backupsDir)
        except OSError, (errno, strerror):
            errMsg = "OSError while creating " + backupsDir + " with errno: " + str(errno) + " and strerr: " + strerror
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)

    return backupsDir

@echo
def backupSnapshot(session, args):
    util.SMlog("Called backupSnapshot with " + str(args))
    primaryStorageSRUuid      = args['primaryStorageSRUuid']
    snapshotUuid              = args['snapshotUuid']
    volumeName                = args['volumeName']
    secondaryStorageMountPath = args['secondaryStorageMountPath']
    lastBackedUpBaseCopy      = args['lastBackedUpSnapshotUuid']
    isFirstSnapshotOfRootVolume = args['isFirstSnapshotOfRootVolume']

    primarySRPath = os.path.join(SR.MOUNT_BASE, primaryStorageSRUuid)
    snapshotVHD  = snapshotUuid + '.' + SR.DEFAULT_TAP
    snapshotPath = os.path.join(primarySRPath, snapshotVHD)
    
    baseCopyUuid = getParent(snapshotPath)
    baseCopyPath = os.path.join(primarySRPath, baseCopyUuid)
    baseCopyPath = baseCopyPath + '.' + SR.DEFAULT_TAP
    util.SMlog("Base copy path: " + baseCopyPath)

    # Mount secondary storage mount path on XenServer along the path
    # /var/run/sr-mount/snapshots/ and create <volumeName> dir on it.
    backupsDir = mountSecondaryStorage(secondaryStorageMountPath, volumeName)
    util.SMlog("Backups dir " + backupsDir)

    # chdir to the backupsDir for convenience
    chdir(backupsDir)
    baseCopyVHD = baseCopyUuid + '.' + SR.DEFAULT_TAP
    lastBackedUpVHD = ''
    if (len(lastBackedUpBaseCopy) != 0):
        lastBackedUpVHD = lastBackedUpBaseCopy + '.' + SR.DEFAULT_TAP

    if baseCopyUuid == lastBackedUpBaseCopy:
        # lastBackedUpBaseCopy exists.
        # There has been no change since the last snapshot so no need to backup 

        try:
            if not os.path.isfile(lastBackedUpVHD):
               util.SMlog("Serious error. Last known backed up base copy " + lastBackedUpVHD + " is not present. Trying to backup it again")
            else:
                # The backing up is already done. So return without doing anything further.
                # Set the uuid of the current backup to that of last backup
                txt = "1#" + lastBackedUpBaseCopy
                return txt
        except OSError, (errno, strerror):
            errMsg = "OSError while checking existence of " + lastBackedUpVHD + " with errno: " + str(errno) + " and strerr: " + strerror
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)

    # If we reach here, there is no backup present and we have to do one.

    # Check existence of snapshot on primary storage 
    isfile(baseCopyPath)
    # copy baseCopyPath to backupsDir
    copyfile(baseCopyPath, backupsDir)

    # Because the primary storage is always scanned, the parent of this base copy is always the first base copy.
    # We don't want that, we want a chain of VHDs each of which is a delta from the previous.
    # So set the parent of the current baseCopyVHD to lastBackedUpVHD
    if (lastBackedUpVHD):
        # If there was a previous backup
        setParent(lastBackedUpVHD, baseCopyVHD)

    
    if (isFirstSnapshotOfRootVolume) and (isFirstSnapshotOfRootVolume == 'true'):
        # First snapshot of the root volume.
        # It's parent is not null, but the template vhd.
        # Create a dummy with the same virtual size as all the snapshots and set the parent of backupVHD to it.
        # This will prevent deleteSnapshotBackup and createVolumeFromSnapshot from breaking
        dummyVhd = ''
        try:
            newUUID = util.gen_uuid()
            dummyVhd = newUUID + '.' + SR.DEFAULT_TAP
            cmd = [VHD_UTIL, 'query', '-v', '-n', baseCopyVHD]
            virtualSizeInMB = util.pread2(cmd)
            util.SMlog("Virtual size of " + baseCopyVHD + " is " + virtualSizeInMB)
            cmd = [VHD_UTIL, 'create', '-n', dummyVhd, '-s', virtualSizeInMB]
            txt = util.pread2(cmd)
        except:
            txt = ''
            errMsg = "Unexpected error while creating a dummy VHD " + dummyVhd + " with virtual size " + virtualSizeInMB + " on " + backupsDir
            util.SMlog(errMsg)
            xs_errors.XenError(errMsg)
        util.SMlog("Successfully created a new dummy vhd " + dummyVhd + " with virtual size " + virtualSizeInMB + " on " + backupsDir)

        # Set the parent of backupVhd to dummyVhd
        setParent(dummyVhd, baseCopyVHD)

    txt = "1#" + baseCopyUuid
    return txt

@echo
def deleteSnapshotBackup(session, args):
    util.SMlog("Calling deleteSnapshotBackup with " + str(args))
    volumeName                = args['volumeName']
    secondaryStorageMountPath = args['secondaryStorageMountPath']
    backupUUID                = args['backupUUID']
    childUUID                 = args['childUUID']

    backupsDir = mountSecondaryStorage(secondaryStorageMountPath, volumeName)
    # chdir to the backupsDir for convenience
    chdir(backupsDir)

    backupVHD = backupUUID + '.' + SR.DEFAULT_TAP
    util.SMlog("checking existence of " + backupVHD)
    isfile(backupVHD)

    # Case 1) childUUID exists
    # I know empty strings default to false, but feel it's obscure programming.
    if (childUUID is not None) and (len(childUUID) != 0):
        coalesceToChild(backupVHD, childUUID)
    else:
        # Just delete the backupVHD
        try:
            os.remove(backupVHD)
        except OSError, (errno, strerror):
            errMsg = "OSError while removing " + backupVHD + " with errno: " + str(errno) + " and strerr: " + strerror
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)

    return "1"

@echo
def createVolumeFromSnapshot(session, args):
    util.SMlog("Calling createVolumeFromSnapshot with " + str(args))
    primaryStorageSRUuid      = args['primaryStorageSRUuid']
    volumeName                = args['volumeName']
    secondaryStorageMountPath = args['secondaryStorageMountPath']
    backedUpSnapshotUuid      = args['backedUpSnapshotUuid']

    primarySRPath = os.path.join(SR.MOUNT_BASE, primaryStorageSRUuid)

    backupsDir = mountSecondaryStorage(secondaryStorageMountPath, volumeName)
    util.SMlog("Backups dir " + backupsDir)

    # chdir to the backupsDir for convenience
    chdir(backupsDir)

    # Get the parent VHD chain of the backupSnapshotVHD
    vhdChain = []
    uuid = backedUpSnapshotUuid
    while uuid is not None:
        util.SMlog("Current uuid in parent chain " + uuid)
        vhd = uuid + '.' + SR.DEFAULT_TAP
        vhdChain.append(vhd)
        try:
            uuid = vhdutil.getParent(vhd, cleanup.FileVDI.extractUuid)
        except:
            errMsg = "Unexpected error while trying to get parent of " + vhd 
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)   
    util.SMlog("successfully created the parent chain " + str(vhdChain))
    # Copy all the vhds to a temp directory
    # Create a temp directory
    tempDir = backupsDir + '_temp'

    # Delete the temp directory if it already exists (from a previous createVolumeFromSnapshot)
    rmtree(tempDir)
    
    # Now create a new one.
    try:
        os.mkdir(tempDir)
    except OSError, (errno, strerror):
        errMsg = "OSError while creating tempDir with errno: " + str(errno) + " and strerr: " + strerror
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)

    # Copy
    for vhd in vhdChain:
        vhdPath = os.path.join(backupsDir, vhd)
        copyfile(vhdPath, tempDir)
    util.SMlog("Successfully copied all files")

    # coalesce the vhd chains from bottom to top
    # chdir to tempDir for convenience
    chdir(tempDir)
       
    # coalesce
    i = 0
    for vhd in vhdChain:
        if i == (len(vhdChain) - 1):
            # last vhd, has no parent. Don't coalesce
            break
        i = i + 1
        # They are arranged from child to parent.
        util.SMlog("Starting to coalesce " + vhd + " with its parent")
        try:
            cmd = [VHD_UTIL, "coalesce", "-n", vhd]
            txt = util.pread2(cmd)
        except:
            errMsg = "Unexpected error while trying to coalesce " + vhd + " to its parent" 
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)
        util.SMlog("Successfully coalesced " + vhd + " with its parent")

        # Remove the child vhd
        try:
            os.remove(vhd)
        except OSError, (errno, strerror):
            errMsg = "OSError while removing " + vhd + " with errno: " + str(errno) + " and strerr: " + strerror
            util.SMlog(errMsg)
            raise xs_errors.XenError(errMsg)
    
    finalVhd = vhdChain[len(vhdChain) - 1]
    util.SMlog("successfully coalesced all vhds to the parent " + finalVhd)
    
    # There is already a VDI (the original one from which this snapshot was taken)
    # If we try to introduce this snapshot as it is, it will give an error saying uniqueness conflict.
    # Rename the vhd with a new uuid so that it can get introduced into the VDI database
    # generate a uuid
    newUUID = ''
    try:
        newUUID = util.gen_uuid()
    except:
        errMsg = "Unexpected error while trying to generate a uuid"
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)
    util.SMlog("generated a uuid " + newUUID)

    newVhd = newUUID + '.' + SR.DEFAULT_TAP
    rename(finalVhd, newVhd)

    # set the hidden flag of the final VHD to false, so that it doesn't get deleted when the SR scan is done.
    try:
        vhdutil.setHidden(newVhd, False)
    except:
        errMsg = "Unexpected error while trying to set Hidden flag of " + newVhd
        util.SMlog(errMsg)
        raise xs_errors.XenError(errMsg)
    util.SMlog("Successfully set hidden flag of " + newVhd)

    # The old method of copying the VHD directly to primary storage and doing a VDI.introduce doesn't work anymore
    # There is a more complex process being done in XenServerResource.
    return "1#" + newUUID 

def rmtree(path):
    if os.path.isdir(path):
        try:
            shutil.rmtree(path)
        except OSError, (errno, strerror):
            errMsg = "Error while deleting " + path + " on secondary storage with errno: " + str(errno) + " and strerr: " + strerror + ". Please delete it manually"
            util.SMlog(errMsg)
        util.SMlog("Successfully deleted " + path)
    else:
        util.SMlog("Could not find directory with path " + path)
    return

@echo
def stitchSnapshotDeltaToTemplate(session, args):
    util.SMlog("Calling stitchSnapshotDeltaToTemplate with " + str(args))
    primaryStorageSRUuid = args['primaryStorageSRUuid']
    rootVdiUUID          = args['rootVdiUUID']
    snapshotVdiUUID      = args['snapshotVdiUUID']

    primarySRPath = os.path.join(SR.MOUNT_BASE, primaryStorageSRUuid)
    rootVHD = rootVdiUUID + '.' + SR.DEFAULT_TAP
    rootVhdPath = os.path.join(primarySRPath, rootVHD)

    snapshotVHD = snapshotVdiUUID + '.' + SR.DEFAULT_TAP
    snapshotVHDPath = os.path.join(primarySRPath, snapshotVHD)
    setParent(rootVhdPath, snapshotVHDPath)

    return "1"

@echo
def networkUsage(session, args):
    sargs = args['args']
    cmd = sargs.split(' ')
    cmd.insert(0, "/opt/xensource/bin/networkUsage.sh")
    cmd.insert(0, "/bin/bash")
    try:
        txt = util.pread2(cmd)
    except:
        util.SMlog("  network usage error "  )
        txt = '' 

    return txt

if __name__ == "__main__":
    XenAPIPlugin.dispatch({"gethostvmstats": gethostvmstats, "getvncport": getvncport, "getnetwork": getnetwork, "preparemigration": preparemigration, "setIptables": setIptables, "patchdomr": patchdomr, "pingdomr": pingdomr, "ipassoc": ipassoc, "savePassword": savePassword, "saveDhcpEntry": saveDhcpEntry, "setFirewallRule": setFirewallRule, "checkMount": checkMount, "backupSnapshot": backupSnapshot, "deleteSnapshotBackup": deleteSnapshotBackup, "createVolumeFromSnapshot": createVolumeFromSnapshot, "stitchSnapshotDeltaToTemplate": stitchSnapshotDeltaToTemplate, "networkUsage": networkUsage})
